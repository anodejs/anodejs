# Introduction

While it is possible now to run ANODE applications on the real cloud, it would be nice to have an option to run and debug them on the developer's computer.

ANODE can run on the development machine. The last becomes just like another single instance farm in the cluster.

In the development environment one can execute all applications just like they are executed on Azure. ANODE dashboard works in the development environment too. Besides local debugging, the development environment allows logs browsing for other farms in the cluster, even if these farms are not accessible for some reason.

# Setup steps

The master branch of the cluster repository bears settings for development environment. Set current branch of the cluster repository on the develoment machine to ```master```.

## Configure farm setting for development environment

```farms.json``` in ```rebus``` directory on the ```master``` branch of cluster repository should look like https://github.com/anodejs/sample-cluster/blob/master/rebus/farm.json (don't forget to set Azure account like [here](https://github.com/anodejs/anodejs/blob/master/docs/SIMPLE_SETUP.md#update-farmjson), but not the farm name).

Set Azure storage account name and keys.

Push changes to the origin.

## Setup emulated topology

Copy topology configuration file ```topology.json``` from https://github.com/anodejs/sample-cluster/blob/master/rebus/topology.json to ```rebus``` directory of the ```master``` branch of the cluster repository. On Azure, this file is generated from Azure configuration. For development environment it should be present in the directory. The file emulates environment of a single instance of your emulated farm.

## Setup empty deployment settings

Copy empty deployment settings from https://github.com/anodejs/sample-cluster/blob/master/rebus/deploy.json to ```rebus``` directory on the ```master``` branch of the cluster repository.

On the development environment, deployment is not invoked. Instead, developers setup ANODE repositories themselves.

## Setup logging configuration

Copy development environment logging configuration from https://github.com/anodejs/sample-cluster/blob/master/rebus/log.json to ```rebus``` directory of the ```master``` branch of the cluster repository. 

In addition to Azure table logging transport, the configuration for development environment lists settings for the console transport, which lets you see logs live in console window.

# Developers guide

By a few simple steps each developer can install ANODE on his development computer.

While on Azure ANODE system takes care of automatic deployment in accordance to farm administrator settings, on developer's computer the computer owner himself plays the role of farm administrator. The deployment system is not invoked in development environment. The developer himself installs ANODE system and application repositories according to his/her needs.

## Clone repositories

To execute ANODE on the local host, one needs to clone system and cluster repositories and to place them in a certain way next to each other.

Create a directory for ANODE on your computer. Let's assume you chose it to be ```c:\anode```.

Clone ANODE system into ```__system``` directory. Clone the cluster repository into ```cluster``` directory. The naming of directories is important and it shouldn't be altered. 

Keep current branch of the cluster repository to be ```master```. This branch is reserved for development environment.

## Clone applications repositories

Consult your ANODE administrator about deployment policy that governs the namespace reserved for application repositories. In most cases, application repositories are placed next to the system repository. For example, in our example, you will clone applicaiton repository ```rrr``` into ```c:\anode\rrr```

## Create applications metadata

Since deployment service is not invoked automatically on development environment, developed should invoke metadata creation script manually. In ```cli``` directory of the system repository execute ```compile.cmd``` script to create the required metadata. The parameters to the script are directory names that include ANODE applications the owner of the computer is willing to execute. This should always include ```system``` directory, which includes ANODE system applications. The script invokation would look like:

```
C:\anode\__system\cli>compile __system rrr
```

## Start ANODE on development computer

You can start ANODE by invoking ANODE's root process aka reverse proxy. Go to ```sys\rp``` subdirectory of your system repository. Run the script ```.shimmed.v6.index.js``` that was generated by ```compile.cmd``` in this directory. The invocation will look like:

```
C:\anode\__system\sys\rp>node .shimmed.v6.index.js
```

The console window will show live logs for all applications invoked on your local farm.

## Getting to the dashboard

You can access your emulated farm dashboard via http://localhost:40000 in your browser. This is fully functional dashboard running on your machine.

## Getting to ANODE application

You can get to applications, by appending their names to http://localhost:40000 URL. For example, to invoke previously created application ```aaa.rrr```, you will go with http://localhost:4000/aaa.rrr

## Running application independently from ANODE environment

ANODE application is just a node.js script named ```index.js```, which opens HTTP server ```PORT``` defined in environment by ANODE.

Most ANODE applications are able to run independently of ANODE. Such applications should not assume ```PORT``` is always defined in the environment and to have fallback, in case the variable is not defined.

Another consideration is regarding node modules that are required by applications. Under ANODE, node modules can be loaded from ANODE system. If application is required independently it should find required node modules on the developer's machine. One possibility is to install required node modules in the application repository. This, however, sometimes wasteful, if the same modules is already supplied by ANODE system. Another alternative is to install modules globally on the developer computer, so they will be accessible for applications invoked independently.