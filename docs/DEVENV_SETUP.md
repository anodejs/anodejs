# Introduction

While it is possible now to run ANODE applications on the real cloud, it would be nice to have an option to run and debug them on the developer's computer.

ANODE can run on the development machine. The last becomes just like another single instance farm in the cluster.

In the development environment one can execute all applications just like they are executed on Azure. ANODE dashboard works in the development environment too. Besides local debugging, the development environment allows logs browsing for other farms in the cluster, even if these farms are not accessible for some reason.

# Setup steps

The master branch of the cluster repository bears settings for development environment. Set current branch of the cluster repository on the develoment machine to ```master```.

## Configure farm setting for development environment

```farms.json``` in ```rebus``` directory on the ```master``` branch of cluster repository should look like https://github.com/anodejs/sample-cluster/blob/master/rebus/farm.json (don't forget to set Azure account like [here](https://github.com/anodejs/anodejs/blob/master/docs/SIMPLE_SETUP.md#update-farmjson), but not the farm name).

Push changes to the origin.

## Setup emulated topology

Copy topology configuration file ```topology.json``` from https://github.com/anodejs/sample-cluster/blob/master/rebus/topology.json to ```rebus``` directory of the ```master``` branch of the cluster repository. On Azure, this file is generated from Azure configuration. For development environment it should be present in the directory. The file emulates environment of a single instance of the emulated farm.

## Setup empty deployment settings

Copy empty deployment settings from https://github.com/anodejs/sample-cluster/blob/master/rebus/deploy.json to ```rebus``` directory on the ```master``` branch of the cluster repository.

On the development environment, deployment is not invoked. Instead, developers setup ANODE repositories themselves.

## Setup logging configuration

Copy development environment logging configuration from https://github.com/anodejs/sample-cluster/blob/master/rebus/log.json to ```rebus``` directory of the ```master``` branch of the cluster repository. 

In addition to Azure table logging transport, the configuration for development environment lists settings for the console transport, which write the logs live, in the console window.

# Developers guide

By a few simple steps each developer can install ANODE on his development computer.

While on Azure, ANODE system takes care of automatic deployment in accordance to farm administrator settings, on developer's computer the computer owner himself plays the role of the farm administrator. The deployment system is not invoked in the development environment. The developer installs ANODE system and application repositories according to his/her needs.

## Clone repositories

To execute ANODE on the local host, one needs to clone system and cluster repositories and to place them in a certain way next to each other.

Create a directory for ANODE. Let's assume you chose it to be ```c:\anode```.

Clone ANODE system into ```__system``` directory. Clone the cluster repository into ```cluster``` directory. The naming of these directories is important and it shouldn't be altered. 

Keep the current branch of the cluster repository to be ```master```. This branch is reserved for the development environment.

## Clone applications repositories

Consult ANODE cluster administrator about deployment policy that governs the namespace reserved for application repositories. In most cases, application repositories are placed next to the system repository. For example, in [this ANODE setup manual example](https://github.com/anodejs/anodejs/blob/master/docs/APPREPO_SETUP.md#configure-deployment), the application repository ```rrr``` should be cloned into ```c:\anode\rrr```

## Create applications metadata

Since deployment service is not invoked automatically on the development environment, developers have to invoke metadata creation script manually. In ```cli``` directory of the system repository execute ```compile.cmd``` script to create the required metadata. The parameters for the script are directory names, which include ANODE applications, the owner of the computer is willing to execute. This should always include ```__system``` directory. The script invokation would look like:

```
C:\anode\__system\cli>compile __system rrr
```

## Start ANODE on the development computer

Start ANODE by invoking ANODE's root process aka reverse proxy. Go to ```sys\rp``` subdirectory of the system repository. Run the script ```.shimmed.v6.index.js``` that was generated by ```compile.cmd``` in this directory. The invocation looks like:

```
C:\anode\__system\sys\rp>node .shimmed.v6.index.js
```

The console shows live logs for all applications invoked on the local emulated farm.

## Getting to the dashboard

Access emulated local farm dashboard via http://localhost:40000 in the browser. This is fully functional dashboard.

## Getting to ANODE application

Get to applications, by appending their names to http://localhost:40000 URL. For example, to invoke previously created application ```aaa.rrr```, browse to http://localhost:4000/aaa.rrr

## Running application independently from ANODE environment

ANODE application is just a node.js script named ```index.js```, which opens HTTP server ```PORT``` defined in the environment by ANODE.

Most ANODE applications are able to run independently of ANODE. Such applications should not assume ```PORT``` is always defined in the environment and to have fallback for the case the variable is not defined.

Another consideration is regarding node modules that are required by applications. Under ANODE, node modules can be loaded from ANODE system. If application is invoked not in ANODE environment, it should find required node modules on the developer's machine. One possibility is to install required node modules in the application repository. This, however, sometimes wasteful, if the same modules is already supplied by ANODE system. Another alternative is to install modules globally on the developer computer.